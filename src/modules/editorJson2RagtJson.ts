import $ from 'jquery';
import { BLOCK_TYPE, CLASS_NAME } from '../constant/index'

const dfsTree = (root: any, arr: any) => {
  arr.push(root.content);
  root.items.forEach((item: any) => {
    dfsTree(item, arr);
  });
};

const splitSentences = (rawText: any, lang = "en") => {
  const htmlElementRegex =
    /<(?:([A-Za-z0-9][A-Za-z0-9]*)\b[^>]*>(?:.*?)<\/\1>|[A-Za-z0-9][A-Za-z0-9]*\b[^>]*\/>)/gm;
  const htmlElements = rawText.match(htmlElementRegex) ?? [];
  let noHtml = rawText;
  htmlElements.forEach(
    (element: any, idx: any) =>
      (noHtml = noHtml.replace(element, `htmlElementNo${idx}`))
  );
  const regexSplitSentences =
    lang === "ja"
      ? /((?<!\w\.\w.)(?:\。|\n))/g
      : /((?<!\w\.\w.)(?<![A-Z][a-z]\.)(?:\.|\n)\s)/g

  const noHtmlSentences = noHtml
    .replace(regexSplitSentences, '$1|')
    .split('|')
    .filter((sentences: any) => !!sentences);

  let newNoHtmlSentences: Array<string> = [], j = 0;
  for(let i = 0; i < noHtmlSentences.length; i++) {
    if (i === 0) {
      newNoHtmlSentences[j] = noHtmlSentences[i]
    } else {
      if (newNoHtmlSentences[j].length <= 10) {
        newNoHtmlSentences[j] += noHtmlSentences[i]
      } else {
        j += 1;
        newNoHtmlSentences[j] = noHtmlSentences[i]
      }
    }
  }

  const sentences = newNoHtmlSentences.map((sentence: any) => {
    htmlElements.forEach(
      (element: any, idx: any) =>
        (sentence = sentence.replace(`htmlElementNo${idx}`, element))
    );
    return sentence;
  });
  return sentences;
};

const getMetaByDfs = (root: any, parentId: any, arr: any) => {
  if (root.content) {
    // random attribute id
    const id = Math.random().toString(36).substring(7);
    const sentences = splitSentences(root.content);
    sentences.forEach((sentence: any) => {
      const htmlTagRegex = /<\/?[a-z][a-z0-9]*[^<>]*>|<!--.*?-->/gim;
      const aTagRegex = /<a.+?\s*href\s*=\s*["\']?(?<href>[^"\'\s>]+)["\']?/gi;
      arr.push({
        parentId,
        id,
        ui: sentence,
        polly: sentence.replace(htmlTagRegex, ""),
        ssml: "",
        user: "",
        actions: [...sentence.matchAll(aTagRegex)].map((item) => item.groups?.href),
        soundType: 'polly'
      });
    });
    root.items.forEach((item: any) => {
      getMetaByDfs(item, id, arr);
    });
  } else {
    root.items.forEach((item: any) => {
      getMetaByDfs(item, "root", arr);
    });
  }
};

const editorJson2RagtJson = (editorJson: any, lang = "en") => {
  const getListAnnotation = (data: any) => {
    let itemsArr: any = [];
    dfsTree(data, itemsArr);

    itemsArr = itemsArr.filter((item: any) => item);
    if (lang === "ja") {
      return `これは${
        data.style === "ordered" ? "番号付き" : "箇条書きの"
      }リストで, ${data.items.length}個の項目と${
        itemsArr.length - data.items.length
      }個のサブ項目があります。`;
    }
    if (lang === "vi") {
      return `Đây là danh sách được ${
        data.style === "ordered" ? "đánh số" : "gạch đầu dòng"
      }, danh sách có ${data.items.length} mục chính và ${
        itemsArr.length - data.items.length
      } mục phụ.`;
    }
    return `This is ${
      data.style === "ordered" ? "Numbered" : "Bulleted"
    } list, there are ${data.items.length} items and ${
      itemsArr.length - data.items.length
    } sub items`;
  };
  const getImageAnnotation = (alt: string) => {
    if (alt) {
      const annotation: any = {
        ja: `ここに「${alt}」の画像があります。`,
        vi: `Đây là hình ảnh về ${alt}`,
        en: `This image is about ${alt}.`,
      };
      return annotation[lang] || annotation.en;
    } else {
      const annotation: any = {
        ja: "ここに画像があります。",
        vi: "Đây là một bức hình",
        en: "There is a image",
      };
      return annotation[lang] || annotation.en;
    }
  };
  const buildMetaTable = (data: any) => {
    const withHeadings = data.withHeadings;
    const content = [...data.content];
    const totalRows = content?.length ?? 0;
    const totalCols = content[0]?.length ?? 0;

    if (lang === 'ja') {
      const annotation = `この下に、<span class="${CLASS_NAME.highlightText}">縦${totalRows}行</span>、<span class="${CLASS_NAME.highlightText}">横${totalCols}列</span>の表(ひょう)があります。`;
      const meta: any = [
        {
          id: Math.random().toString(36).substring(7),
          ui: annotation,
          polly: $(`<p>${annotation}</p>`)?.text(),
          ssml: '',
          user: '',
          actions: [],
          isAutogenerated: true,
          soundType: 'polly'
        },
      ];
      if (data.caption) {
        const title = `表(ひょう)のタイトルは、${data.caption}、です。`;
        meta.push({
          id: Math.random().toString(36).substring(7),
          ui: data.caption,
          polly: $(`<p>${title}</p>`)?.text(),
          ssml: '',
          user: '',
          actions: [],
          isAutogenerated: true,
          soundType: 'polly'
        })
      }

      let index = 0;
      content.forEach((row, idx) => {
        let polly = ''
        if (idx === 0 && withHeadings) {
          polly = `見出し行は左から、${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join('、')
          }です。`
          index += 1
        } else if (idx === 0 && !withHeadings) {
          polly = `データの1行目、${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join('、')
          }`
          index += 2
        } else {
          polly = `${(index === 1 ? 'データの1行目' : `${index}行目`)}、${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join('、')
          }${(idx === row.length - 1) ? '、です。' : ''}`
          index += 1
        }
        polly = $(`<p>${polly}</p>`).text();
        let ui = `<tr role="row" tabindex="0" aria-label="${polly}">`;
        row.forEach((cell: any) => {
          const className = (withHeadings && idx === 0) ? `class="${CLASS_NAME.tableHeader}"` : ''
          ui += `<td ${className} aria-hidden="true">${cell}</td>`
        });
        ui = ui.concat('</tr>');
        meta.push({
          ui,
          polly,
          ssml: '',
          user: '',
          actions: [],
          soundType: 'polly'
        });
      });
      meta.push({
        id: Math.random().toString(36).substring(7),
        ui: `表(ひょう)の終わりです。`,
        polly: `表(ひょう)の終わりです。`,
        ssml: '',
        user: '',
        actions: [],
        isAutogenerated: true,
        soundType: 'polly'
      });
      return meta;
    } else if (lang === 'vi') {
      const annotation = `Đây là dữ liệu dạng bảng, <span class="${CLASS_NAME.highlightText}">có ${totalRows} dòng</span>, <span class="${CLASS_NAME.highlightText}">${totalCols} cột</span>.`;
      const meta: any = [
        {
          id: Math.random().toString(36).substring(7),
          ui: annotation,
          polly: $(`<p>${annotation}</p>`)?.text(),
          ssml: '',
          user: '',
          actions: [],
          isAutogenerated: true,
          soundType: 'polly'
        },
      ];

      if (data.caption) {
        const title = `Tiêu đề của bảng là <span class="${CLASS_NAME.highlightText}">${data.caption}</span>.`;
        meta.push({
            id: Math.random().toString(36).substring(7),
            ui: title,
            polly: $(`<p>${title}</p>`)?.text(),
            ssml: '',
            user: '',
            actions: [],
            isAutogenerated: true,
            soundType: 'polly'
          })
      }

      let index = 0;
      content.forEach((row, idx) => {
        let polly = ""
        if (idx === 0 && withHeadings) {
          polly = `Dòng tiêu đề là ${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join(', ')
          }, bắt đầu từ trái sang phải.`
          index += 1
        } else if (idx === 0 && !withHeadings) {
          polly = `Dòng thứ nhất là ${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join(', ')
          }`
          index += 2
        } else {
          polly = `Dòng thứ ${index} là ${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join(', ')
          }`
          index += 1
        }
        polly = $(`<p>${polly}</p>`).text();
        let ui = `<tr role="row" tabindex="0" aria-label="${polly}">`;
        row.forEach((cell: string) => {
          const className = (withHeadings && idx === 0) ? `class="${CLASS_NAME.tableHeader}"` : ''
          ui += `<td ${className} aria-hidden="true">${cell}</td>`
        });
        ui = ui.concat('</tr>');
        meta.push({
          ui,
          polly,
          ssml: '',
          user: '',
          actions: [],
          soundType: 'polly'
        });
      });
      meta.push({
        id: Math.random().toString(36).substring(7),
        ui: `Kết thúc bảng.`,
        polly: `Kết thúc bảng.`,
        ssml: '',
        user: '',
        actions: [],
        isAutogenerated: true,
        soundType: 'polly'
      });
      return meta;
    } else {
      let annotation = `This is table with <span class="${CLASS_NAME.highlightText}">${totalRows} rows</span>, <span class="${CLASS_NAME.highlightText}">${totalCols} columns</span>.`;
      const meta: any = [
        {
          id: Math.random().toString(36).substring(7),
          ui: annotation,
          polly: $(`<p>${annotation}</p>`)?.text(),
          ssml: '',
          user: '',
          actions: [],
          isAutogenerated: true,
          soundType: 'polly'
        },
      ];

      if (data.caption) {
      const title = `The title of the table is <span class="${CLASS_NAME.highlightText}">${data.caption}</span>.`;
        meta.push({
          id: Math.random().toString(36).substring(7),
          ui: title,
          polly: $(`<p>${title}</p>`)?.text(),
          ssml: '',
          user: '',
          actions: [],
          isAutogenerated: true,
          soundType: 'polly'
        })
      }

      let index = 0;
      content.forEach((row, idx) => {
        let polly = ""
        if (idx === 0 && withHeadings) {
          polly = `The table headers are ${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join(', ')
          }.`
          index += 1
        } else if (idx === 0 && !withHeadings) {
          polly = `The first line of data is ${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join(', ')
          }`
          index += 2
        } else {
          polly = `Line ${index}: ${row
            .filter((cell: string) => cell)
            .map((cell: string) => cell)
            .join(', ')
          }`
          index += 1
        }
        polly = $(`<p>${polly}</p>`).text();
        let ui = `<tr role="row" tabindex="0" aria-label="${polly}">`;
        row.forEach((cell: string) => {
          const className = (withHeadings && idx === 0) ? `class="${CLASS_NAME.tableHeader}"` : ''
          ui += `<td ${className} aria-hidden="true">${cell}</td>`
        });
        ui = ui.concat('</tr>');
        meta.push({
          ui,
          polly,
          ssml: '',
          user: '',
          actions: [],
          soundType: 'polly'
        });
      });

      meta.push({
        id: Math.random().toString(36).substring(7),
        ui: `End table.`,
        polly: `End table.`,
        ssml: '',
        user: '',
        actions: [],
        isAutogenerated: true,
        soundType: 'polly'
      });
      return meta;
    }
  };

  //TODO: Generate meta data for each block
  const blocks = editorJson.blocks.map((block: any) => {
    let meta: any = [];
    //TODO: Paragraph, Header
    if ([BLOCK_TYPE.HEADER, BLOCK_TYPE.PARAGRAPH].includes(block.type)) {
      const sentences = splitSentences(block.data.text, lang);
      meta = sentences
        .map((sentence: string) => {
        const htmlTagRegex = /<\/?[a-z][a-z0-9]*[^<>]*>|<!--.*?-->/gim;
        const aTagRegex =
          /<a.+?\s*href\s*=\s*["\']?(?<href>[^"\'\s>]+)["\']?/gi;
        return {
          ui: sentence.replace('\n', '<br />'),
          polly: sentence.replace(htmlTagRegex, "")?.trim(),
          ssml: "",
          user: "",
          actions: [...sentence.matchAll(aTagRegex)]
            .filter((item) => item && item.groups && item.groups?.href)
            .map((item) => item.groups?.href),
          soundType: 'polly'
        };
      });
    }

    //TODO: List
    if (block.type === BLOCK_TYPE.LIST) {
      let items: any = [];
      getMetaByDfs(block.data, "id", items);
      meta = [...items];
      meta = [
        {
          ui: getListAnnotation(block.data),
          polly: getListAnnotation(block.data),
          ssml: "",
          user: "",
          actions: [],
          isAutogenerated: true,
          soundType: 'polly'
        },
        ...meta,
      ];
    }

    //TODO: Image
    if (block.type === BLOCK_TYPE.IMAGE) {
      meta = [
        {
          ui: getImageAnnotation(block.data.caption),
          polly: getImageAnnotation(block.data.caption),
          ssml: "",
          user: "",
          actions: [],
          soundType: 'polly'
        },
      ];
    }

    //TODO: Table
    if (block.type === BLOCK_TYPE.TABLE) {
      meta = buildMetaTable(block.data);
    }
    return {
      ...block,
      meta,
    };
  });

  return {
    ...editorJson,
    blocks,
  };
};

export default editorJson2RagtJson